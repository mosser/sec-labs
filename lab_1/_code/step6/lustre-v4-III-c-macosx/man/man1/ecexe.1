.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ECEXE 1"
.TH ECEXE 1 "2015-03-18" "lustre v4, release III.a" "Lustre V4 Distribution"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ecexe \- Lustre expanded code simulation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBecexe\fR \fIfile\fR\fB.ec\fR [ \fBoptions\fR ]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This tool takes a \fIstand-alone\fR ec program, 
i.e. a program that does not require external constants and functions
(see below for details). The predefined types are supported; 
more precisely, Booleans and integers are implemented by the machine
type \fBint\fR, and reals are implemented by \fBdouble\fR values. 
It simulates the reactive behavior of the program,
reading input values on \fBstdin\fR, and writing
outputs on \fBstdout\fR.
.SS "Stand-alone ec program"
.IX Subsection "Stand-alone ec program"
Basically, an ec node is said to be \fIstand-alone\fR if it only deals
with pre-defined types (\fBbool\fR, \fBint\fR, \fBreal\fR), and does not require
any external function or constant. This is the general rule, but 
however, there exist several exceptions:
.IP "\(bu" 4
External types are interpreted as enumerated types.
The only values of this type are supposed to be the declared 
constants of this type. Polymorphic operators are supported
(\f(CW\*(C`=\*(C'\fR, \f(CW\*(C`\-\*(C'\fR>, \f(CW\*(C`if then else\*(C'\fR, \f(CW\*(C`pre\*(C'\fR, \f(CW\*(C`when\*(C'\fR, \f(CW\*(C`current\*(C'\fR).
.IP "\(bu" 4
Usual double-precision functions are supported; their names are those
of the standard C header \fBmath.h\fR, and, indeed, they are implemented 
by the corresponding function in \fBlibm.a\fR library (see below
for details).
.SS "Supported mathematical functions"
.IX Subsection "Supported mathematical functions"
Those functions must be declared in the lustre source with their
exact names and parameter types. A file \fBluslib/math.lus\fR is provided
in the distribution; it contains the following declarations:
.PP
.Vb 10
\&        function acos  (x: real) returns (y: real);
\&        function asin  (x: real) returns (y: real);
\&        function atan  (x: real) returns (y: real);
\&        function cos   (x: real) returns (y: real);
\&        function sin   (x: real) returns (y: real);
\&        function tan   (x: real) returns (y: real);
\&        function cosh  (x: real) returns (y: real);
\&        function sinh  (x: real) returns (y: real);
\&        function tanh  (x: real) returns (y: real);
\&        function exp   (x: real) returns (y: real);
\&        function log   (x: real) returns (y: real);
\&        function log10 (x: real) returns (y: real);
\&        function pow   (x: real) returns (y: real);
\&        function sqrt  (x: real) returns (y: real);
\&        function fabs  (x: real) returns (y: real);
\&        function ceil  (x: real) returns (y: real);
\&        function floor (x: real) returns (y: real);
.Ve
.SS "Reactive Input Format (\fBrif\fP)"
.IX Subsection "Reactive Input Format (rif)"
At each step, the interpretor reads on \fBstdin\fR a value for each input.
The input flow is supposed to follow the \fBrif\fR (Reactive Input Format)
conventions: the input flow consists of a sequence of basic values
(Booleans, integers, reals, strings) separated by spaces 
(predicate \fBispace\fR from \fBctype.h\fR library). 
Moreover, comments and pragmas can be written in the input flow:
.IP "\(bu" 4
All characters comprised between a \f(CW\*(C`#\*(C'\fR and the next new-line are
considered as a comment (resp. a pragma), and ignored (resp. treated if
the pragma is supported).
.IP "\(bu" 4
All characters comprised between \f(CW\*(C`#@\*(C'\fR and the next
\&\f(CW\*(C`@#\*(C'\fR is also considered as a comment.
.PP
The only pragma supported by \fBecexe\fR is the string \fBreset\fR, which 
causes the interpreter to restart in its initial state.
.PP
The syntax for integer and real values is the ansi-C one.
.PP
For Boolean values, the interpreter accepts:
.IP "\(bu" 4
\&\fB0\fR, \fBf\fR or \fBF\fR for false,
.IP "\(bu" 4
\&\fB1\fR, \fBt\fR or \fBT\fR for true.
.PP
When the interpreter has read all input values, it performs a
computation step, writes the corresponding outputs on \fBstdout\fR,
reads a new input vector and so on.
.PP
For instance, there is a valid input file for a node that takes 
one Boolean input and two integer inputs:
.PP
.Vb 12
\&        t 0 2 
\&        #this line is ignored
\&        f 5 6 t 56 \-12 #two steps on a single line
\&        #@
\&        all 
\&        those
\&        characters are
\&        ignored @# f 42 #this end of line is ignored
\&        \-10  #this is the end of the previous step
\&        #reset
\&        #@ the interpreter has been restarted @#
\&        t 5 6
.Ve
.PP
Note that new-lines have no special meaning: a new step is performed
as soon as a whole input vector is available.
.SS "Missing values"
.IX Subsection "Missing values"
In order to interpret programs whose inputs are not always defined
(clocked inputs) the value \fB?\fR is accepted for any type.
For instance, the following input sequence is correct for a node
whose header is
.PP
\&\fBnode \s-1CLOCKED\s0(c : bool; (x : real) when c)\fR:
.PP
.Vb 7
\&        t 42e2
\&        f ?
\&        f ?
\&        t 24  #integer notation is accepted for real values
\&        t \-3.14
\&        f ?
\&        f 22.2E\-10 #this value will be ignored anyway...
.Ve
.PP
The symbol \fB?\fR is also used for undefined outputs.
.SS "Nil value"
.IX Subsection "Nil value"
When some output takes the value of an uninitialized variable, the
interpreter normally stops with error code 1. But there is an option
that inhibits this feature: in this case the interpreter outputs
the string \fBnil\fR and goes on.
.SS "Reset"
.IX Subsection "Reset"
All comments begining with the string \fBreset\fR,
are interpreted as a reset command: the interpretation
restarts from the begining, just as if a new process had been
called for the remaining input file.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-r\fR (reactive)" 4
.IX Item "-r (reactive)"
inhibits all buffer mechanism  on files (to be used with command pipes).
.IP "\fB\-n\fR" 4
.IX Item "-n"
outputs the string \fBnil\fR for non initialized value, instead of
exiting with error code \fB1\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
lustre, lus2ec, ecexe, luciole, simec, lus2oc, ec2oc, ocmin, lus2atg, oc2atg,
ec2c, poc, lux, lesar, ecverif, xlesar
